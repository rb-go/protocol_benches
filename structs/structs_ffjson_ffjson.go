// Code generated by ffjson <https://github.com/pquerna/ffjson>. DO NOT EDIT.
// source: structs_ffjson.go

package structs

import (
	"bytes"
	"fmt"
	fflib "github.com/pquerna/ffjson/fflib/v1"
)

// MarshalJSON marshal bytes to json - template
func (j *FFItems) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *FFItems) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"etag":`)
	fflib.WriteJsonString(buf, string(j.Etag))
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteString(`,"kind":`)
	fflib.WriteJsonString(buf, string(j.Kind))
	buf.WriteString(`,"snippet":`)

	{

		err = j.Snippet.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtFFItemsbase = iota
	ffjtFFItemsnosuchkey

	ffjtFFItemsEtag

	ffjtFFItemsID

	ffjtFFItemsKind

	ffjtFFItemsSnippet
)

var ffjKeyFFItemsEtag = []byte("etag")

var ffjKeyFFItemsID = []byte("id")

var ffjKeyFFItemsKind = []byte("kind")

var ffjKeyFFItemsSnippet = []byte("snippet")

// UnmarshalJSON umarshall json - template of ffjson
func (j *FFItems) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *FFItems) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtFFItemsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtFFItemsnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'e':

					if bytes.Equal(ffjKeyFFItemsEtag, kn) {
						currentKey = ffjtFFItemsEtag
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyFFItemsID, kn) {
						currentKey = ffjtFFItemsID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffjKeyFFItemsKind, kn) {
						currentKey = ffjtFFItemsKind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyFFItemsSnippet, kn) {
						currentKey = ffjtFFItemsSnippet
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyFFItemsSnippet, kn) {
					currentKey = ffjtFFItemsSnippet
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFItemsKind, kn) {
					currentKey = ffjtFFItemsKind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFItemsID, kn) {
					currentKey = ffjtFFItemsID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFItemsEtag, kn) {
					currentKey = ffjtFFItemsEtag
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtFFItemsnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtFFItemsEtag:
					goto handle_Etag

				case ffjtFFItemsID:
					goto handle_ID

				case ffjtFFItemsKind:
					goto handle_Kind

				case ffjtFFItemsSnippet:
					goto handle_Snippet

				case ffjtFFItemsnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Etag:

	/* handler: j.Etag type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Etag = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Kind:

	/* handler: j.Kind type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Kind = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Snippet:

	/* handler: j.Snippet type=structs.FFSnippet kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.Snippet.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *FFJSON) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *FFJSON) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"aliceblue":`)
	fflib.WriteJsonString(buf, string(j.Aliceblue))
	buf.WriteString(`,"antiquewhite":`)
	fflib.WriteJsonString(buf, string(j.Antiquewhite))
	buf.WriteString(`,"aqua":`)
	fflib.WriteJsonString(buf, string(j.Aqua))
	buf.WriteString(`,"aquamarine":`)
	fflib.WriteJsonString(buf, string(j.Aquamarine))
	buf.WriteString(`,"azure":`)
	fflib.WriteJsonString(buf, string(j.Azure))
	buf.WriteString(`,"beige":`)
	fflib.WriteJsonString(buf, string(j.Beige))
	buf.WriteString(`,"bisque":`)
	fflib.WriteJsonString(buf, string(j.Bisque))
	buf.WriteString(`,"black":`)
	fflib.WriteJsonString(buf, string(j.Black))
	buf.WriteString(`,"blanchedalmond":`)
	fflib.WriteJsonString(buf, string(j.Blanchedalmond))
	buf.WriteString(`,"blue":`)
	fflib.WriteJsonString(buf, string(j.Blue))
	buf.WriteString(`,"blueviolet":`)
	fflib.WriteJsonString(buf, string(j.Blueviolet))
	buf.WriteString(`,"brown":`)
	fflib.WriteJsonString(buf, string(j.Brown))
	buf.WriteString(`,"burlywood":`)
	fflib.WriteJsonString(buf, string(j.Burlywood))
	buf.WriteString(`,"cadetblue":`)
	fflib.WriteJsonString(buf, string(j.Cadetblue))
	buf.WriteString(`,"chartreuse":`)
	fflib.WriteJsonString(buf, string(j.Chartreuse))
	buf.WriteString(`,"chocolate":`)
	fflib.WriteJsonString(buf, string(j.Chocolate))
	buf.WriteString(`,"coral":`)
	fflib.WriteJsonString(buf, string(j.Coral))
	buf.WriteString(`,"cornflowerblue":`)
	fflib.WriteJsonString(buf, string(j.Cornflowerblue))
	buf.WriteString(`,"cornsilk":`)
	fflib.WriteJsonString(buf, string(j.Cornsilk))
	buf.WriteString(`,"crimson":`)
	fflib.WriteJsonString(buf, string(j.Crimson))
	buf.WriteString(`,"cyan":`)
	fflib.WriteJsonString(buf, string(j.Cyan))
	buf.WriteString(`,"darkblue":`)
	fflib.WriteJsonString(buf, string(j.Darkblue))
	buf.WriteString(`,"darkcyan":`)
	fflib.WriteJsonString(buf, string(j.Darkcyan))
	buf.WriteString(`,"darkgoldenrod":`)
	fflib.WriteJsonString(buf, string(j.Darkgoldenrod))
	buf.WriteString(`,"darkgray":`)
	fflib.WriteJsonString(buf, string(j.Darkgray))
	buf.WriteString(`,"darkgreen":`)
	fflib.WriteJsonString(buf, string(j.Darkgreen))
	buf.WriteString(`,"darkgrey":`)
	fflib.WriteJsonString(buf, string(j.Darkgrey))
	buf.WriteString(`,"darkkhaki":`)
	fflib.WriteJsonString(buf, string(j.Darkkhaki))
	buf.WriteString(`,"darkmagenta":`)
	fflib.WriteJsonString(buf, string(j.Darkmagenta))
	buf.WriteString(`,"darkolivegreen":`)
	fflib.WriteJsonString(buf, string(j.Darkolivegreen))
	buf.WriteString(`,"darkorange":`)
	fflib.WriteJsonString(buf, string(j.Darkorange))
	buf.WriteString(`,"darkorchid":`)
	fflib.WriteJsonString(buf, string(j.Darkorchid))
	buf.WriteString(`,"darkred":`)
	fflib.WriteJsonString(buf, string(j.Darkred))
	buf.WriteString(`,"darksalmon":`)
	fflib.WriteJsonString(buf, string(j.Darksalmon))
	buf.WriteString(`,"darkseagreen":`)
	fflib.WriteJsonString(buf, string(j.Darkseagreen))
	buf.WriteString(`,"darkslateblue":`)
	fflib.WriteJsonString(buf, string(j.Darkslateblue))
	buf.WriteString(`,"darkslategray":`)
	fflib.WriteJsonString(buf, string(j.Darkslategray))
	buf.WriteString(`,"darkslategrey":`)
	fflib.WriteJsonString(buf, string(j.Darkslategrey))
	buf.WriteString(`,"darkturquoise":`)
	fflib.WriteJsonString(buf, string(j.Darkturquoise))
	buf.WriteString(`,"darkviolet":`)
	fflib.WriteJsonString(buf, string(j.Darkviolet))
	buf.WriteString(`,"deeppink":`)
	fflib.WriteJsonString(buf, string(j.Deeppink))
	buf.WriteString(`,"deepskyblue":`)
	fflib.WriteJsonString(buf, string(j.Deepskyblue))
	buf.WriteString(`,"dimgray":`)
	fflib.WriteJsonString(buf, string(j.Dimgray))
	buf.WriteString(`,"dimgrey":`)
	fflib.WriteJsonString(buf, string(j.Dimgrey))
	buf.WriteString(`,"dodgerblue":`)
	fflib.WriteJsonString(buf, string(j.Dodgerblue))
	buf.WriteString(`,"firebrick":`)
	fflib.WriteJsonString(buf, string(j.Firebrick))
	buf.WriteString(`,"floralwhite":`)
	fflib.WriteJsonString(buf, string(j.Floralwhite))
	buf.WriteString(`,"forestgreen":`)
	fflib.WriteJsonString(buf, string(j.Forestgreen))
	buf.WriteString(`,"fuchsia":`)
	fflib.WriteJsonString(buf, string(j.Fuchsia))
	buf.WriteString(`,"gainsboro":`)
	fflib.WriteJsonString(buf, string(j.Gainsboro))
	buf.WriteString(`,"ghostwhite":`)
	fflib.WriteJsonString(buf, string(j.Ghostwhite))
	buf.WriteString(`,"gold":`)
	fflib.WriteJsonString(buf, string(j.Gold))
	buf.WriteString(`,"goldenrod":`)
	fflib.WriteJsonString(buf, string(j.Goldenrod))
	buf.WriteString(`,"gray":`)
	fflib.WriteJsonString(buf, string(j.Gray))
	buf.WriteString(`,"green":`)
	fflib.WriteJsonString(buf, string(j.Green))
	buf.WriteString(`,"greenyellow":`)
	fflib.WriteJsonString(buf, string(j.Greenyellow))
	buf.WriteString(`,"grey":`)
	fflib.WriteJsonString(buf, string(j.Grey))
	buf.WriteString(`,"honeydew":`)
	fflib.WriteJsonString(buf, string(j.Honeydew))
	buf.WriteString(`,"hotpink":`)
	fflib.WriteJsonString(buf, string(j.Hotpink))
	buf.WriteString(`,"indianred":`)
	fflib.WriteJsonString(buf, string(j.Indianred))
	buf.WriteString(`,"indigo":`)
	fflib.WriteJsonString(buf, string(j.Indigo))
	buf.WriteString(`,"ivory":`)
	fflib.WriteJsonString(buf, string(j.Ivory))
	buf.WriteString(`,"khaki":`)
	fflib.WriteJsonString(buf, string(j.Khaki))
	buf.WriteString(`,"lavender":`)
	fflib.WriteJsonString(buf, string(j.Lavender))
	buf.WriteString(`,"lavenderblush":`)
	fflib.WriteJsonString(buf, string(j.Lavenderblush))
	buf.WriteString(`,"lawngreen":`)
	fflib.WriteJsonString(buf, string(j.Lawngreen))
	buf.WriteString(`,"lemonchiffon":`)
	fflib.WriteJsonString(buf, string(j.Lemonchiffon))
	buf.WriteString(`,"lightblue":`)
	fflib.WriteJsonString(buf, string(j.Lightblue))
	buf.WriteString(`,"lightcoral":`)
	fflib.WriteJsonString(buf, string(j.Lightcoral))
	buf.WriteString(`,"lightcyan":`)
	fflib.WriteJsonString(buf, string(j.Lightcyan))
	buf.WriteString(`,"lightgoldenrodyellow":`)
	fflib.WriteJsonString(buf, string(j.Lightgoldenrodyellow))
	buf.WriteString(`,"lightgray":`)
	fflib.WriteJsonString(buf, string(j.Lightgray))
	buf.WriteString(`,"lightgreen":`)
	fflib.WriteJsonString(buf, string(j.Lightgreen))
	buf.WriteString(`,"lightgrey":`)
	fflib.WriteJsonString(buf, string(j.Lightgrey))
	buf.WriteString(`,"lightpink":`)
	fflib.WriteJsonString(buf, string(j.Lightpink))
	buf.WriteString(`,"lightsalmon":`)
	fflib.WriteJsonString(buf, string(j.Lightsalmon))
	buf.WriteString(`,"lightseagreen":`)
	fflib.WriteJsonString(buf, string(j.Lightseagreen))
	buf.WriteString(`,"lightskyblue":`)
	fflib.WriteJsonString(buf, string(j.Lightskyblue))
	buf.WriteString(`,"lightslategray":`)
	fflib.WriteJsonString(buf, string(j.Lightslategray))
	buf.WriteString(`,"lightslategrey":`)
	fflib.WriteJsonString(buf, string(j.Lightslategrey))
	buf.WriteString(`,"lightsteelblue":`)
	fflib.WriteJsonString(buf, string(j.Lightsteelblue))
	buf.WriteString(`,"lightyellow":`)
	fflib.WriteJsonString(buf, string(j.Lightyellow))
	buf.WriteString(`,"lime":`)
	fflib.WriteJsonString(buf, string(j.Lime))
	buf.WriteString(`,"limegreen":`)
	fflib.WriteJsonString(buf, string(j.Limegreen))
	buf.WriteString(`,"linen":`)
	fflib.WriteJsonString(buf, string(j.Linen))
	buf.WriteString(`,"magenta":`)
	fflib.WriteJsonString(buf, string(j.Magenta))
	buf.WriteString(`,"maroon":`)
	fflib.WriteJsonString(buf, string(j.Maroon))
	buf.WriteString(`,"mediumaquamarine":`)
	fflib.WriteJsonString(buf, string(j.Mediumaquamarine))
	buf.WriteString(`,"mediumblue":`)
	fflib.WriteJsonString(buf, string(j.Mediumblue))
	buf.WriteString(`,"mediumorchid":`)
	fflib.WriteJsonString(buf, string(j.Mediumorchid))
	buf.WriteString(`,"mediumpurple":`)
	fflib.WriteJsonString(buf, string(j.Mediumpurple))
	buf.WriteString(`,"mediumseagreen":`)
	fflib.WriteJsonString(buf, string(j.Mediumseagreen))
	buf.WriteString(`,"mediumslateblue":`)
	fflib.WriteJsonString(buf, string(j.Mediumslateblue))
	buf.WriteString(`,"mediumspringgreen":`)
	fflib.WriteJsonString(buf, string(j.Mediumspringgreen))
	buf.WriteString(`,"mediumturquoise":`)
	fflib.WriteJsonString(buf, string(j.Mediumturquoise))
	buf.WriteString(`,"mediumvioletred":`)
	fflib.WriteJsonString(buf, string(j.Mediumvioletred))
	buf.WriteString(`,"midnightblue":`)
	fflib.WriteJsonString(buf, string(j.Midnightblue))
	buf.WriteString(`,"mintcream":`)
	fflib.WriteJsonString(buf, string(j.Mintcream))
	buf.WriteString(`,"mistyrose":`)
	fflib.WriteJsonString(buf, string(j.Mistyrose))
	buf.WriteString(`,"moccasin":`)
	fflib.WriteJsonString(buf, string(j.Moccasin))
	buf.WriteString(`,"navajowhite":`)
	fflib.WriteJsonString(buf, string(j.Navajowhite))
	buf.WriteString(`,"navy":`)
	fflib.WriteJsonString(buf, string(j.Navy))
	buf.WriteString(`,"oldlace":`)
	fflib.WriteJsonString(buf, string(j.Oldlace))
	buf.WriteString(`,"olive":`)
	fflib.WriteJsonString(buf, string(j.Olive))
	buf.WriteString(`,"olivedrab":`)
	fflib.WriteJsonString(buf, string(j.Olivedrab))
	buf.WriteString(`,"orange":`)
	fflib.WriteJsonString(buf, string(j.Orange))
	buf.WriteString(`,"orangered":`)
	fflib.WriteJsonString(buf, string(j.Orangered))
	buf.WriteString(`,"orchid":`)
	fflib.WriteJsonString(buf, string(j.Orchid))
	buf.WriteString(`,"palegoldenrod":`)
	fflib.WriteJsonString(buf, string(j.Palegoldenrod))
	buf.WriteString(`,"palegreen":`)
	fflib.WriteJsonString(buf, string(j.Palegreen))
	buf.WriteString(`,"paleturquoise":`)
	fflib.WriteJsonString(buf, string(j.Paleturquoise))
	buf.WriteString(`,"palevioletred":`)
	fflib.WriteJsonString(buf, string(j.Palevioletred))
	buf.WriteString(`,"papayawhip":`)
	fflib.WriteJsonString(buf, string(j.Papayawhip))
	buf.WriteString(`,"peachpuff":`)
	fflib.WriteJsonString(buf, string(j.Peachpuff))
	buf.WriteString(`,"peru":`)
	fflib.WriteJsonString(buf, string(j.Peru))
	buf.WriteString(`,"pink":`)
	fflib.WriteJsonString(buf, string(j.Pink))
	buf.WriteString(`,"plum":`)
	fflib.WriteJsonString(buf, string(j.Plum))
	buf.WriteString(`,"powderblue":`)
	fflib.WriteJsonString(buf, string(j.Powderblue))
	buf.WriteString(`,"purple":`)
	fflib.WriteJsonString(buf, string(j.Purple))
	buf.WriteString(`,"rebeccapurple":`)
	fflib.WriteJsonString(buf, string(j.Rebeccapurple))
	buf.WriteString(`,"red":`)
	fflib.WriteJsonString(buf, string(j.Red))
	buf.WriteString(`,"rosybrown":`)
	fflib.WriteJsonString(buf, string(j.Rosybrown))
	buf.WriteString(`,"royalblue":`)
	fflib.WriteJsonString(buf, string(j.Royalblue))
	buf.WriteString(`,"saddlebrown":`)
	fflib.WriteJsonString(buf, string(j.Saddlebrown))
	buf.WriteString(`,"salmon":`)
	fflib.WriteJsonString(buf, string(j.Salmon))
	buf.WriteString(`,"sandybrown":`)
	fflib.WriteJsonString(buf, string(j.Sandybrown))
	buf.WriteString(`,"seagreen":`)
	fflib.WriteJsonString(buf, string(j.Seagreen))
	buf.WriteString(`,"seashell":`)
	fflib.WriteJsonString(buf, string(j.Seashell))
	buf.WriteString(`,"sienna":`)
	fflib.WriteJsonString(buf, string(j.Sienna))
	buf.WriteString(`,"silver":`)
	fflib.WriteJsonString(buf, string(j.Silver))
	buf.WriteString(`,"skyblue":`)
	fflib.WriteJsonString(buf, string(j.Skyblue))
	buf.WriteString(`,"slateblue":`)
	fflib.WriteJsonString(buf, string(j.Slateblue))
	buf.WriteString(`,"slategray":`)
	fflib.WriteJsonString(buf, string(j.Slategray))
	buf.WriteString(`,"slategrey":`)
	fflib.WriteJsonString(buf, string(j.Slategrey))
	buf.WriteString(`,"snow":`)
	fflib.WriteJsonString(buf, string(j.Snow))
	buf.WriteString(`,"springgreen":`)
	fflib.WriteJsonString(buf, string(j.Springgreen))
	buf.WriteString(`,"steelblue":`)
	fflib.WriteJsonString(buf, string(j.Steelblue))
	buf.WriteString(`,"tan":`)
	fflib.WriteJsonString(buf, string(j.Tan))
	buf.WriteString(`,"teal":`)
	fflib.WriteJsonString(buf, string(j.Teal))
	buf.WriteString(`,"thistle":`)
	fflib.WriteJsonString(buf, string(j.Thistle))
	buf.WriteString(`,"tomato":`)
	fflib.WriteJsonString(buf, string(j.Tomato))
	buf.WriteString(`,"turquoise":`)
	fflib.WriteJsonString(buf, string(j.Turquoise))
	buf.WriteString(`,"violet":`)
	fflib.WriteJsonString(buf, string(j.Violet))
	buf.WriteString(`,"wheat":`)
	fflib.WriteJsonString(buf, string(j.Wheat))
	buf.WriteString(`,"white":`)
	fflib.WriteJsonString(buf, string(j.White))
	buf.WriteString(`,"whitesmoke":`)
	fflib.WriteJsonString(buf, string(j.Whitesmoke))
	buf.WriteString(`,"yellow":`)
	fflib.WriteJsonString(buf, string(j.Yellow))
	buf.WriteString(`,"yellowgreen":`)
	fflib.WriteJsonString(buf, string(j.Yellowgreen))
	buf.WriteString(`,"youtube":`)

	{

		err = j.Youtube.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtFFJSONbase = iota
	ffjtFFJSONnosuchkey

	ffjtFFJSONAliceblue

	ffjtFFJSONAntiquewhite

	ffjtFFJSONAqua

	ffjtFFJSONAquamarine

	ffjtFFJSONAzure

	ffjtFFJSONBeige

	ffjtFFJSONBisque

	ffjtFFJSONBlack

	ffjtFFJSONBlanchedalmond

	ffjtFFJSONBlue

	ffjtFFJSONBlueviolet

	ffjtFFJSONBrown

	ffjtFFJSONBurlywood

	ffjtFFJSONCadetblue

	ffjtFFJSONChartreuse

	ffjtFFJSONChocolate

	ffjtFFJSONCoral

	ffjtFFJSONCornflowerblue

	ffjtFFJSONCornsilk

	ffjtFFJSONCrimson

	ffjtFFJSONCyan

	ffjtFFJSONDarkblue

	ffjtFFJSONDarkcyan

	ffjtFFJSONDarkgoldenrod

	ffjtFFJSONDarkgray

	ffjtFFJSONDarkgreen

	ffjtFFJSONDarkgrey

	ffjtFFJSONDarkkhaki

	ffjtFFJSONDarkmagenta

	ffjtFFJSONDarkolivegreen

	ffjtFFJSONDarkorange

	ffjtFFJSONDarkorchid

	ffjtFFJSONDarkred

	ffjtFFJSONDarksalmon

	ffjtFFJSONDarkseagreen

	ffjtFFJSONDarkslateblue

	ffjtFFJSONDarkslategray

	ffjtFFJSONDarkslategrey

	ffjtFFJSONDarkturquoise

	ffjtFFJSONDarkviolet

	ffjtFFJSONDeeppink

	ffjtFFJSONDeepskyblue

	ffjtFFJSONDimgray

	ffjtFFJSONDimgrey

	ffjtFFJSONDodgerblue

	ffjtFFJSONFirebrick

	ffjtFFJSONFloralwhite

	ffjtFFJSONForestgreen

	ffjtFFJSONFuchsia

	ffjtFFJSONGainsboro

	ffjtFFJSONGhostwhite

	ffjtFFJSONGold

	ffjtFFJSONGoldenrod

	ffjtFFJSONGray

	ffjtFFJSONGreen

	ffjtFFJSONGreenyellow

	ffjtFFJSONGrey

	ffjtFFJSONHoneydew

	ffjtFFJSONHotpink

	ffjtFFJSONIndianred

	ffjtFFJSONIndigo

	ffjtFFJSONIvory

	ffjtFFJSONKhaki

	ffjtFFJSONLavender

	ffjtFFJSONLavenderblush

	ffjtFFJSONLawngreen

	ffjtFFJSONLemonchiffon

	ffjtFFJSONLightblue

	ffjtFFJSONLightcoral

	ffjtFFJSONLightcyan

	ffjtFFJSONLightgoldenrodyellow

	ffjtFFJSONLightgray

	ffjtFFJSONLightgreen

	ffjtFFJSONLightgrey

	ffjtFFJSONLightpink

	ffjtFFJSONLightsalmon

	ffjtFFJSONLightseagreen

	ffjtFFJSONLightskyblue

	ffjtFFJSONLightslategray

	ffjtFFJSONLightslategrey

	ffjtFFJSONLightsteelblue

	ffjtFFJSONLightyellow

	ffjtFFJSONLime

	ffjtFFJSONLimegreen

	ffjtFFJSONLinen

	ffjtFFJSONMagenta

	ffjtFFJSONMaroon

	ffjtFFJSONMediumaquamarine

	ffjtFFJSONMediumblue

	ffjtFFJSONMediumorchid

	ffjtFFJSONMediumpurple

	ffjtFFJSONMediumseagreen

	ffjtFFJSONMediumslateblue

	ffjtFFJSONMediumspringgreen

	ffjtFFJSONMediumturquoise

	ffjtFFJSONMediumvioletred

	ffjtFFJSONMidnightblue

	ffjtFFJSONMintcream

	ffjtFFJSONMistyrose

	ffjtFFJSONMoccasin

	ffjtFFJSONNavajowhite

	ffjtFFJSONNavy

	ffjtFFJSONOldlace

	ffjtFFJSONOlive

	ffjtFFJSONOlivedrab

	ffjtFFJSONOrange

	ffjtFFJSONOrangered

	ffjtFFJSONOrchid

	ffjtFFJSONPalegoldenrod

	ffjtFFJSONPalegreen

	ffjtFFJSONPaleturquoise

	ffjtFFJSONPalevioletred

	ffjtFFJSONPapayawhip

	ffjtFFJSONPeachpuff

	ffjtFFJSONPeru

	ffjtFFJSONPink

	ffjtFFJSONPlum

	ffjtFFJSONPowderblue

	ffjtFFJSONPurple

	ffjtFFJSONRebeccapurple

	ffjtFFJSONRed

	ffjtFFJSONRosybrown

	ffjtFFJSONRoyalblue

	ffjtFFJSONSaddlebrown

	ffjtFFJSONSalmon

	ffjtFFJSONSandybrown

	ffjtFFJSONSeagreen

	ffjtFFJSONSeashell

	ffjtFFJSONSienna

	ffjtFFJSONSilver

	ffjtFFJSONSkyblue

	ffjtFFJSONSlateblue

	ffjtFFJSONSlategray

	ffjtFFJSONSlategrey

	ffjtFFJSONSnow

	ffjtFFJSONSpringgreen

	ffjtFFJSONSteelblue

	ffjtFFJSONTan

	ffjtFFJSONTeal

	ffjtFFJSONThistle

	ffjtFFJSONTomato

	ffjtFFJSONTurquoise

	ffjtFFJSONViolet

	ffjtFFJSONWheat

	ffjtFFJSONWhite

	ffjtFFJSONWhitesmoke

	ffjtFFJSONYellow

	ffjtFFJSONYellowgreen

	ffjtFFJSONYoutube
)

var ffjKeyFFJSONAliceblue = []byte("aliceblue")

var ffjKeyFFJSONAntiquewhite = []byte("antiquewhite")

var ffjKeyFFJSONAqua = []byte("aqua")

var ffjKeyFFJSONAquamarine = []byte("aquamarine")

var ffjKeyFFJSONAzure = []byte("azure")

var ffjKeyFFJSONBeige = []byte("beige")

var ffjKeyFFJSONBisque = []byte("bisque")

var ffjKeyFFJSONBlack = []byte("black")

var ffjKeyFFJSONBlanchedalmond = []byte("blanchedalmond")

var ffjKeyFFJSONBlue = []byte("blue")

var ffjKeyFFJSONBlueviolet = []byte("blueviolet")

var ffjKeyFFJSONBrown = []byte("brown")

var ffjKeyFFJSONBurlywood = []byte("burlywood")

var ffjKeyFFJSONCadetblue = []byte("cadetblue")

var ffjKeyFFJSONChartreuse = []byte("chartreuse")

var ffjKeyFFJSONChocolate = []byte("chocolate")

var ffjKeyFFJSONCoral = []byte("coral")

var ffjKeyFFJSONCornflowerblue = []byte("cornflowerblue")

var ffjKeyFFJSONCornsilk = []byte("cornsilk")

var ffjKeyFFJSONCrimson = []byte("crimson")

var ffjKeyFFJSONCyan = []byte("cyan")

var ffjKeyFFJSONDarkblue = []byte("darkblue")

var ffjKeyFFJSONDarkcyan = []byte("darkcyan")

var ffjKeyFFJSONDarkgoldenrod = []byte("darkgoldenrod")

var ffjKeyFFJSONDarkgray = []byte("darkgray")

var ffjKeyFFJSONDarkgreen = []byte("darkgreen")

var ffjKeyFFJSONDarkgrey = []byte("darkgrey")

var ffjKeyFFJSONDarkkhaki = []byte("darkkhaki")

var ffjKeyFFJSONDarkmagenta = []byte("darkmagenta")

var ffjKeyFFJSONDarkolivegreen = []byte("darkolivegreen")

var ffjKeyFFJSONDarkorange = []byte("darkorange")

var ffjKeyFFJSONDarkorchid = []byte("darkorchid")

var ffjKeyFFJSONDarkred = []byte("darkred")

var ffjKeyFFJSONDarksalmon = []byte("darksalmon")

var ffjKeyFFJSONDarkseagreen = []byte("darkseagreen")

var ffjKeyFFJSONDarkslateblue = []byte("darkslateblue")

var ffjKeyFFJSONDarkslategray = []byte("darkslategray")

var ffjKeyFFJSONDarkslategrey = []byte("darkslategrey")

var ffjKeyFFJSONDarkturquoise = []byte("darkturquoise")

var ffjKeyFFJSONDarkviolet = []byte("darkviolet")

var ffjKeyFFJSONDeeppink = []byte("deeppink")

var ffjKeyFFJSONDeepskyblue = []byte("deepskyblue")

var ffjKeyFFJSONDimgray = []byte("dimgray")

var ffjKeyFFJSONDimgrey = []byte("dimgrey")

var ffjKeyFFJSONDodgerblue = []byte("dodgerblue")

var ffjKeyFFJSONFirebrick = []byte("firebrick")

var ffjKeyFFJSONFloralwhite = []byte("floralwhite")

var ffjKeyFFJSONForestgreen = []byte("forestgreen")

var ffjKeyFFJSONFuchsia = []byte("fuchsia")

var ffjKeyFFJSONGainsboro = []byte("gainsboro")

var ffjKeyFFJSONGhostwhite = []byte("ghostwhite")

var ffjKeyFFJSONGold = []byte("gold")

var ffjKeyFFJSONGoldenrod = []byte("goldenrod")

var ffjKeyFFJSONGray = []byte("gray")

var ffjKeyFFJSONGreen = []byte("green")

var ffjKeyFFJSONGreenyellow = []byte("greenyellow")

var ffjKeyFFJSONGrey = []byte("grey")

var ffjKeyFFJSONHoneydew = []byte("honeydew")

var ffjKeyFFJSONHotpink = []byte("hotpink")

var ffjKeyFFJSONIndianred = []byte("indianred")

var ffjKeyFFJSONIndigo = []byte("indigo")

var ffjKeyFFJSONIvory = []byte("ivory")

var ffjKeyFFJSONKhaki = []byte("khaki")

var ffjKeyFFJSONLavender = []byte("lavender")

var ffjKeyFFJSONLavenderblush = []byte("lavenderblush")

var ffjKeyFFJSONLawngreen = []byte("lawngreen")

var ffjKeyFFJSONLemonchiffon = []byte("lemonchiffon")

var ffjKeyFFJSONLightblue = []byte("lightblue")

var ffjKeyFFJSONLightcoral = []byte("lightcoral")

var ffjKeyFFJSONLightcyan = []byte("lightcyan")

var ffjKeyFFJSONLightgoldenrodyellow = []byte("lightgoldenrodyellow")

var ffjKeyFFJSONLightgray = []byte("lightgray")

var ffjKeyFFJSONLightgreen = []byte("lightgreen")

var ffjKeyFFJSONLightgrey = []byte("lightgrey")

var ffjKeyFFJSONLightpink = []byte("lightpink")

var ffjKeyFFJSONLightsalmon = []byte("lightsalmon")

var ffjKeyFFJSONLightseagreen = []byte("lightseagreen")

var ffjKeyFFJSONLightskyblue = []byte("lightskyblue")

var ffjKeyFFJSONLightslategray = []byte("lightslategray")

var ffjKeyFFJSONLightslategrey = []byte("lightslategrey")

var ffjKeyFFJSONLightsteelblue = []byte("lightsteelblue")

var ffjKeyFFJSONLightyellow = []byte("lightyellow")

var ffjKeyFFJSONLime = []byte("lime")

var ffjKeyFFJSONLimegreen = []byte("limegreen")

var ffjKeyFFJSONLinen = []byte("linen")

var ffjKeyFFJSONMagenta = []byte("magenta")

var ffjKeyFFJSONMaroon = []byte("maroon")

var ffjKeyFFJSONMediumaquamarine = []byte("mediumaquamarine")

var ffjKeyFFJSONMediumblue = []byte("mediumblue")

var ffjKeyFFJSONMediumorchid = []byte("mediumorchid")

var ffjKeyFFJSONMediumpurple = []byte("mediumpurple")

var ffjKeyFFJSONMediumseagreen = []byte("mediumseagreen")

var ffjKeyFFJSONMediumslateblue = []byte("mediumslateblue")

var ffjKeyFFJSONMediumspringgreen = []byte("mediumspringgreen")

var ffjKeyFFJSONMediumturquoise = []byte("mediumturquoise")

var ffjKeyFFJSONMediumvioletred = []byte("mediumvioletred")

var ffjKeyFFJSONMidnightblue = []byte("midnightblue")

var ffjKeyFFJSONMintcream = []byte("mintcream")

var ffjKeyFFJSONMistyrose = []byte("mistyrose")

var ffjKeyFFJSONMoccasin = []byte("moccasin")

var ffjKeyFFJSONNavajowhite = []byte("navajowhite")

var ffjKeyFFJSONNavy = []byte("navy")

var ffjKeyFFJSONOldlace = []byte("oldlace")

var ffjKeyFFJSONOlive = []byte("olive")

var ffjKeyFFJSONOlivedrab = []byte("olivedrab")

var ffjKeyFFJSONOrange = []byte("orange")

var ffjKeyFFJSONOrangered = []byte("orangered")

var ffjKeyFFJSONOrchid = []byte("orchid")

var ffjKeyFFJSONPalegoldenrod = []byte("palegoldenrod")

var ffjKeyFFJSONPalegreen = []byte("palegreen")

var ffjKeyFFJSONPaleturquoise = []byte("paleturquoise")

var ffjKeyFFJSONPalevioletred = []byte("palevioletred")

var ffjKeyFFJSONPapayawhip = []byte("papayawhip")

var ffjKeyFFJSONPeachpuff = []byte("peachpuff")

var ffjKeyFFJSONPeru = []byte("peru")

var ffjKeyFFJSONPink = []byte("pink")

var ffjKeyFFJSONPlum = []byte("plum")

var ffjKeyFFJSONPowderblue = []byte("powderblue")

var ffjKeyFFJSONPurple = []byte("purple")

var ffjKeyFFJSONRebeccapurple = []byte("rebeccapurple")

var ffjKeyFFJSONRed = []byte("red")

var ffjKeyFFJSONRosybrown = []byte("rosybrown")

var ffjKeyFFJSONRoyalblue = []byte("royalblue")

var ffjKeyFFJSONSaddlebrown = []byte("saddlebrown")

var ffjKeyFFJSONSalmon = []byte("salmon")

var ffjKeyFFJSONSandybrown = []byte("sandybrown")

var ffjKeyFFJSONSeagreen = []byte("seagreen")

var ffjKeyFFJSONSeashell = []byte("seashell")

var ffjKeyFFJSONSienna = []byte("sienna")

var ffjKeyFFJSONSilver = []byte("silver")

var ffjKeyFFJSONSkyblue = []byte("skyblue")

var ffjKeyFFJSONSlateblue = []byte("slateblue")

var ffjKeyFFJSONSlategray = []byte("slategray")

var ffjKeyFFJSONSlategrey = []byte("slategrey")

var ffjKeyFFJSONSnow = []byte("snow")

var ffjKeyFFJSONSpringgreen = []byte("springgreen")

var ffjKeyFFJSONSteelblue = []byte("steelblue")

var ffjKeyFFJSONTan = []byte("tan")

var ffjKeyFFJSONTeal = []byte("teal")

var ffjKeyFFJSONThistle = []byte("thistle")

var ffjKeyFFJSONTomato = []byte("tomato")

var ffjKeyFFJSONTurquoise = []byte("turquoise")

var ffjKeyFFJSONViolet = []byte("violet")

var ffjKeyFFJSONWheat = []byte("wheat")

var ffjKeyFFJSONWhite = []byte("white")

var ffjKeyFFJSONWhitesmoke = []byte("whitesmoke")

var ffjKeyFFJSONYellow = []byte("yellow")

var ffjKeyFFJSONYellowgreen = []byte("yellowgreen")

var ffjKeyFFJSONYoutube = []byte("youtube")

// UnmarshalJSON umarshall json - template of ffjson
func (j *FFJSON) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *FFJSON) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtFFJSONbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtFFJSONnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyFFJSONAliceblue, kn) {
						currentKey = ffjtFFJSONAliceblue
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONAntiquewhite, kn) {
						currentKey = ffjtFFJSONAntiquewhite
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONAqua, kn) {
						currentKey = ffjtFFJSONAqua
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONAquamarine, kn) {
						currentKey = ffjtFFJSONAquamarine
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONAzure, kn) {
						currentKey = ffjtFFJSONAzure
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'b':

					if bytes.Equal(ffjKeyFFJSONBeige, kn) {
						currentKey = ffjtFFJSONBeige
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONBisque, kn) {
						currentKey = ffjtFFJSONBisque
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONBlack, kn) {
						currentKey = ffjtFFJSONBlack
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONBlanchedalmond, kn) {
						currentKey = ffjtFFJSONBlanchedalmond
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONBlue, kn) {
						currentKey = ffjtFFJSONBlue
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONBlueviolet, kn) {
						currentKey = ffjtFFJSONBlueviolet
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONBrown, kn) {
						currentKey = ffjtFFJSONBrown
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONBurlywood, kn) {
						currentKey = ffjtFFJSONBurlywood
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyFFJSONCadetblue, kn) {
						currentKey = ffjtFFJSONCadetblue
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONChartreuse, kn) {
						currentKey = ffjtFFJSONChartreuse
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONChocolate, kn) {
						currentKey = ffjtFFJSONChocolate
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONCoral, kn) {
						currentKey = ffjtFFJSONCoral
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONCornflowerblue, kn) {
						currentKey = ffjtFFJSONCornflowerblue
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONCornsilk, kn) {
						currentKey = ffjtFFJSONCornsilk
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONCrimson, kn) {
						currentKey = ffjtFFJSONCrimson
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONCyan, kn) {
						currentKey = ffjtFFJSONCyan
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyFFJSONDarkblue, kn) {
						currentKey = ffjtFFJSONDarkblue
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONDarkcyan, kn) {
						currentKey = ffjtFFJSONDarkcyan
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONDarkgoldenrod, kn) {
						currentKey = ffjtFFJSONDarkgoldenrod
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONDarkgray, kn) {
						currentKey = ffjtFFJSONDarkgray
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONDarkgreen, kn) {
						currentKey = ffjtFFJSONDarkgreen
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONDarkgrey, kn) {
						currentKey = ffjtFFJSONDarkgrey
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONDarkkhaki, kn) {
						currentKey = ffjtFFJSONDarkkhaki
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONDarkmagenta, kn) {
						currentKey = ffjtFFJSONDarkmagenta
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONDarkolivegreen, kn) {
						currentKey = ffjtFFJSONDarkolivegreen
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONDarkorange, kn) {
						currentKey = ffjtFFJSONDarkorange
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONDarkorchid, kn) {
						currentKey = ffjtFFJSONDarkorchid
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONDarkred, kn) {
						currentKey = ffjtFFJSONDarkred
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONDarksalmon, kn) {
						currentKey = ffjtFFJSONDarksalmon
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONDarkseagreen, kn) {
						currentKey = ffjtFFJSONDarkseagreen
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONDarkslateblue, kn) {
						currentKey = ffjtFFJSONDarkslateblue
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONDarkslategray, kn) {
						currentKey = ffjtFFJSONDarkslategray
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONDarkslategrey, kn) {
						currentKey = ffjtFFJSONDarkslategrey
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONDarkturquoise, kn) {
						currentKey = ffjtFFJSONDarkturquoise
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONDarkviolet, kn) {
						currentKey = ffjtFFJSONDarkviolet
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONDeeppink, kn) {
						currentKey = ffjtFFJSONDeeppink
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONDeepskyblue, kn) {
						currentKey = ffjtFFJSONDeepskyblue
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONDimgray, kn) {
						currentKey = ffjtFFJSONDimgray
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONDimgrey, kn) {
						currentKey = ffjtFFJSONDimgrey
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONDodgerblue, kn) {
						currentKey = ffjtFFJSONDodgerblue
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyFFJSONFirebrick, kn) {
						currentKey = ffjtFFJSONFirebrick
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONFloralwhite, kn) {
						currentKey = ffjtFFJSONFloralwhite
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONForestgreen, kn) {
						currentKey = ffjtFFJSONForestgreen
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONFuchsia, kn) {
						currentKey = ffjtFFJSONFuchsia
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyFFJSONGainsboro, kn) {
						currentKey = ffjtFFJSONGainsboro
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONGhostwhite, kn) {
						currentKey = ffjtFFJSONGhostwhite
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONGold, kn) {
						currentKey = ffjtFFJSONGold
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONGoldenrod, kn) {
						currentKey = ffjtFFJSONGoldenrod
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONGray, kn) {
						currentKey = ffjtFFJSONGray
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONGreen, kn) {
						currentKey = ffjtFFJSONGreen
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONGreenyellow, kn) {
						currentKey = ffjtFFJSONGreenyellow
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONGrey, kn) {
						currentKey = ffjtFFJSONGrey
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffjKeyFFJSONHoneydew, kn) {
						currentKey = ffjtFFJSONHoneydew
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONHotpink, kn) {
						currentKey = ffjtFFJSONHotpink
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyFFJSONIndianred, kn) {
						currentKey = ffjtFFJSONIndianred
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONIndigo, kn) {
						currentKey = ffjtFFJSONIndigo
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONIvory, kn) {
						currentKey = ffjtFFJSONIvory
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffjKeyFFJSONKhaki, kn) {
						currentKey = ffjtFFJSONKhaki
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyFFJSONLavender, kn) {
						currentKey = ffjtFFJSONLavender
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONLavenderblush, kn) {
						currentKey = ffjtFFJSONLavenderblush
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONLawngreen, kn) {
						currentKey = ffjtFFJSONLawngreen
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONLemonchiffon, kn) {
						currentKey = ffjtFFJSONLemonchiffon
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONLightblue, kn) {
						currentKey = ffjtFFJSONLightblue
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONLightcoral, kn) {
						currentKey = ffjtFFJSONLightcoral
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONLightcyan, kn) {
						currentKey = ffjtFFJSONLightcyan
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONLightgoldenrodyellow, kn) {
						currentKey = ffjtFFJSONLightgoldenrodyellow
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONLightgray, kn) {
						currentKey = ffjtFFJSONLightgray
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONLightgreen, kn) {
						currentKey = ffjtFFJSONLightgreen
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONLightgrey, kn) {
						currentKey = ffjtFFJSONLightgrey
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONLightpink, kn) {
						currentKey = ffjtFFJSONLightpink
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONLightsalmon, kn) {
						currentKey = ffjtFFJSONLightsalmon
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONLightseagreen, kn) {
						currentKey = ffjtFFJSONLightseagreen
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONLightskyblue, kn) {
						currentKey = ffjtFFJSONLightskyblue
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONLightslategray, kn) {
						currentKey = ffjtFFJSONLightslategray
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONLightslategrey, kn) {
						currentKey = ffjtFFJSONLightslategrey
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONLightsteelblue, kn) {
						currentKey = ffjtFFJSONLightsteelblue
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONLightyellow, kn) {
						currentKey = ffjtFFJSONLightyellow
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONLime, kn) {
						currentKey = ffjtFFJSONLime
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONLimegreen, kn) {
						currentKey = ffjtFFJSONLimegreen
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONLinen, kn) {
						currentKey = ffjtFFJSONLinen
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyFFJSONMagenta, kn) {
						currentKey = ffjtFFJSONMagenta
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONMaroon, kn) {
						currentKey = ffjtFFJSONMaroon
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONMediumaquamarine, kn) {
						currentKey = ffjtFFJSONMediumaquamarine
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONMediumblue, kn) {
						currentKey = ffjtFFJSONMediumblue
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONMediumorchid, kn) {
						currentKey = ffjtFFJSONMediumorchid
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONMediumpurple, kn) {
						currentKey = ffjtFFJSONMediumpurple
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONMediumseagreen, kn) {
						currentKey = ffjtFFJSONMediumseagreen
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONMediumslateblue, kn) {
						currentKey = ffjtFFJSONMediumslateblue
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONMediumspringgreen, kn) {
						currentKey = ffjtFFJSONMediumspringgreen
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONMediumturquoise, kn) {
						currentKey = ffjtFFJSONMediumturquoise
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONMediumvioletred, kn) {
						currentKey = ffjtFFJSONMediumvioletred
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONMidnightblue, kn) {
						currentKey = ffjtFFJSONMidnightblue
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONMintcream, kn) {
						currentKey = ffjtFFJSONMintcream
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONMistyrose, kn) {
						currentKey = ffjtFFJSONMistyrose
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONMoccasin, kn) {
						currentKey = ffjtFFJSONMoccasin
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyFFJSONNavajowhite, kn) {
						currentKey = ffjtFFJSONNavajowhite
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONNavy, kn) {
						currentKey = ffjtFFJSONNavy
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffjKeyFFJSONOldlace, kn) {
						currentKey = ffjtFFJSONOldlace
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONOlive, kn) {
						currentKey = ffjtFFJSONOlive
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONOlivedrab, kn) {
						currentKey = ffjtFFJSONOlivedrab
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONOrange, kn) {
						currentKey = ffjtFFJSONOrange
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONOrangered, kn) {
						currentKey = ffjtFFJSONOrangered
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONOrchid, kn) {
						currentKey = ffjtFFJSONOrchid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyFFJSONPalegoldenrod, kn) {
						currentKey = ffjtFFJSONPalegoldenrod
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONPalegreen, kn) {
						currentKey = ffjtFFJSONPalegreen
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONPaleturquoise, kn) {
						currentKey = ffjtFFJSONPaleturquoise
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONPalevioletred, kn) {
						currentKey = ffjtFFJSONPalevioletred
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONPapayawhip, kn) {
						currentKey = ffjtFFJSONPapayawhip
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONPeachpuff, kn) {
						currentKey = ffjtFFJSONPeachpuff
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONPeru, kn) {
						currentKey = ffjtFFJSONPeru
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONPink, kn) {
						currentKey = ffjtFFJSONPink
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONPlum, kn) {
						currentKey = ffjtFFJSONPlum
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONPowderblue, kn) {
						currentKey = ffjtFFJSONPowderblue
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONPurple, kn) {
						currentKey = ffjtFFJSONPurple
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyFFJSONRebeccapurple, kn) {
						currentKey = ffjtFFJSONRebeccapurple
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONRed, kn) {
						currentKey = ffjtFFJSONRed
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONRosybrown, kn) {
						currentKey = ffjtFFJSONRosybrown
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONRoyalblue, kn) {
						currentKey = ffjtFFJSONRoyalblue
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyFFJSONSaddlebrown, kn) {
						currentKey = ffjtFFJSONSaddlebrown
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONSalmon, kn) {
						currentKey = ffjtFFJSONSalmon
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONSandybrown, kn) {
						currentKey = ffjtFFJSONSandybrown
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONSeagreen, kn) {
						currentKey = ffjtFFJSONSeagreen
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONSeashell, kn) {
						currentKey = ffjtFFJSONSeashell
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONSienna, kn) {
						currentKey = ffjtFFJSONSienna
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONSilver, kn) {
						currentKey = ffjtFFJSONSilver
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONSkyblue, kn) {
						currentKey = ffjtFFJSONSkyblue
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONSlateblue, kn) {
						currentKey = ffjtFFJSONSlateblue
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONSlategray, kn) {
						currentKey = ffjtFFJSONSlategray
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONSlategrey, kn) {
						currentKey = ffjtFFJSONSlategrey
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONSnow, kn) {
						currentKey = ffjtFFJSONSnow
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONSpringgreen, kn) {
						currentKey = ffjtFFJSONSpringgreen
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONSteelblue, kn) {
						currentKey = ffjtFFJSONSteelblue
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyFFJSONTan, kn) {
						currentKey = ffjtFFJSONTan
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONTeal, kn) {
						currentKey = ffjtFFJSONTeal
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONThistle, kn) {
						currentKey = ffjtFFJSONThistle
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONTomato, kn) {
						currentKey = ffjtFFJSONTomato
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONTurquoise, kn) {
						currentKey = ffjtFFJSONTurquoise
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffjKeyFFJSONViolet, kn) {
						currentKey = ffjtFFJSONViolet
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffjKeyFFJSONWheat, kn) {
						currentKey = ffjtFFJSONWheat
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONWhite, kn) {
						currentKey = ffjtFFJSONWhite
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONWhitesmoke, kn) {
						currentKey = ffjtFFJSONWhitesmoke
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'y':

					if bytes.Equal(ffjKeyFFJSONYellow, kn) {
						currentKey = ffjtFFJSONYellow
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONYellowgreen, kn) {
						currentKey = ffjtFFJSONYellowgreen
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFJSONYoutube, kn) {
						currentKey = ffjtFFJSONYoutube
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONYoutube, kn) {
					currentKey = ffjtFFJSONYoutube
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONYellowgreen, kn) {
					currentKey = ffjtFFJSONYellowgreen
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONYellow, kn) {
					currentKey = ffjtFFJSONYellow
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONWhitesmoke, kn) {
					currentKey = ffjtFFJSONWhitesmoke
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONWhite, kn) {
					currentKey = ffjtFFJSONWhite
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONWheat, kn) {
					currentKey = ffjtFFJSONWheat
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONViolet, kn) {
					currentKey = ffjtFFJSONViolet
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONTurquoise, kn) {
					currentKey = ffjtFFJSONTurquoise
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONTomato, kn) {
					currentKey = ffjtFFJSONTomato
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONThistle, kn) {
					currentKey = ffjtFFJSONThistle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONTeal, kn) {
					currentKey = ffjtFFJSONTeal
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONTan, kn) {
					currentKey = ffjtFFJSONTan
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONSteelblue, kn) {
					currentKey = ffjtFFJSONSteelblue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONSpringgreen, kn) {
					currentKey = ffjtFFJSONSpringgreen
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONSnow, kn) {
					currentKey = ffjtFFJSONSnow
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONSlategrey, kn) {
					currentKey = ffjtFFJSONSlategrey
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONSlategray, kn) {
					currentKey = ffjtFFJSONSlategray
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONSlateblue, kn) {
					currentKey = ffjtFFJSONSlateblue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONSkyblue, kn) {
					currentKey = ffjtFFJSONSkyblue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONSilver, kn) {
					currentKey = ffjtFFJSONSilver
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONSienna, kn) {
					currentKey = ffjtFFJSONSienna
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONSeashell, kn) {
					currentKey = ffjtFFJSONSeashell
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONSeagreen, kn) {
					currentKey = ffjtFFJSONSeagreen
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONSandybrown, kn) {
					currentKey = ffjtFFJSONSandybrown
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONSalmon, kn) {
					currentKey = ffjtFFJSONSalmon
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONSaddlebrown, kn) {
					currentKey = ffjtFFJSONSaddlebrown
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONRoyalblue, kn) {
					currentKey = ffjtFFJSONRoyalblue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONRosybrown, kn) {
					currentKey = ffjtFFJSONRosybrown
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONRed, kn) {
					currentKey = ffjtFFJSONRed
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONRebeccapurple, kn) {
					currentKey = ffjtFFJSONRebeccapurple
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONPurple, kn) {
					currentKey = ffjtFFJSONPurple
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONPowderblue, kn) {
					currentKey = ffjtFFJSONPowderblue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONPlum, kn) {
					currentKey = ffjtFFJSONPlum
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONPink, kn) {
					currentKey = ffjtFFJSONPink
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONPeru, kn) {
					currentKey = ffjtFFJSONPeru
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONPeachpuff, kn) {
					currentKey = ffjtFFJSONPeachpuff
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONPapayawhip, kn) {
					currentKey = ffjtFFJSONPapayawhip
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONPalevioletred, kn) {
					currentKey = ffjtFFJSONPalevioletred
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONPaleturquoise, kn) {
					currentKey = ffjtFFJSONPaleturquoise
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONPalegreen, kn) {
					currentKey = ffjtFFJSONPalegreen
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONPalegoldenrod, kn) {
					currentKey = ffjtFFJSONPalegoldenrod
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONOrchid, kn) {
					currentKey = ffjtFFJSONOrchid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONOrangered, kn) {
					currentKey = ffjtFFJSONOrangered
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONOrange, kn) {
					currentKey = ffjtFFJSONOrange
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONOlivedrab, kn) {
					currentKey = ffjtFFJSONOlivedrab
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONOlive, kn) {
					currentKey = ffjtFFJSONOlive
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONOldlace, kn) {
					currentKey = ffjtFFJSONOldlace
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONNavy, kn) {
					currentKey = ffjtFFJSONNavy
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONNavajowhite, kn) {
					currentKey = ffjtFFJSONNavajowhite
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONMoccasin, kn) {
					currentKey = ffjtFFJSONMoccasin
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONMistyrose, kn) {
					currentKey = ffjtFFJSONMistyrose
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONMintcream, kn) {
					currentKey = ffjtFFJSONMintcream
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONMidnightblue, kn) {
					currentKey = ffjtFFJSONMidnightblue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONMediumvioletred, kn) {
					currentKey = ffjtFFJSONMediumvioletred
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONMediumturquoise, kn) {
					currentKey = ffjtFFJSONMediumturquoise
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONMediumspringgreen, kn) {
					currentKey = ffjtFFJSONMediumspringgreen
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONMediumslateblue, kn) {
					currentKey = ffjtFFJSONMediumslateblue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONMediumseagreen, kn) {
					currentKey = ffjtFFJSONMediumseagreen
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONMediumpurple, kn) {
					currentKey = ffjtFFJSONMediumpurple
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONMediumorchid, kn) {
					currentKey = ffjtFFJSONMediumorchid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONMediumblue, kn) {
					currentKey = ffjtFFJSONMediumblue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONMediumaquamarine, kn) {
					currentKey = ffjtFFJSONMediumaquamarine
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONMaroon, kn) {
					currentKey = ffjtFFJSONMaroon
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONMagenta, kn) {
					currentKey = ffjtFFJSONMagenta
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONLinen, kn) {
					currentKey = ffjtFFJSONLinen
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONLimegreen, kn) {
					currentKey = ffjtFFJSONLimegreen
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONLime, kn) {
					currentKey = ffjtFFJSONLime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONLightyellow, kn) {
					currentKey = ffjtFFJSONLightyellow
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONLightsteelblue, kn) {
					currentKey = ffjtFFJSONLightsteelblue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONLightslategrey, kn) {
					currentKey = ffjtFFJSONLightslategrey
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONLightslategray, kn) {
					currentKey = ffjtFFJSONLightslategray
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONLightskyblue, kn) {
					currentKey = ffjtFFJSONLightskyblue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONLightseagreen, kn) {
					currentKey = ffjtFFJSONLightseagreen
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONLightsalmon, kn) {
					currentKey = ffjtFFJSONLightsalmon
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONLightpink, kn) {
					currentKey = ffjtFFJSONLightpink
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONLightgrey, kn) {
					currentKey = ffjtFFJSONLightgrey
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONLightgreen, kn) {
					currentKey = ffjtFFJSONLightgreen
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONLightgray, kn) {
					currentKey = ffjtFFJSONLightgray
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONLightgoldenrodyellow, kn) {
					currentKey = ffjtFFJSONLightgoldenrodyellow
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONLightcyan, kn) {
					currentKey = ffjtFFJSONLightcyan
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONLightcoral, kn) {
					currentKey = ffjtFFJSONLightcoral
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONLightblue, kn) {
					currentKey = ffjtFFJSONLightblue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONLemonchiffon, kn) {
					currentKey = ffjtFFJSONLemonchiffon
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONLawngreen, kn) {
					currentKey = ffjtFFJSONLawngreen
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONLavenderblush, kn) {
					currentKey = ffjtFFJSONLavenderblush
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONLavender, kn) {
					currentKey = ffjtFFJSONLavender
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONKhaki, kn) {
					currentKey = ffjtFFJSONKhaki
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONIvory, kn) {
					currentKey = ffjtFFJSONIvory
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONIndigo, kn) {
					currentKey = ffjtFFJSONIndigo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONIndianred, kn) {
					currentKey = ffjtFFJSONIndianred
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONHotpink, kn) {
					currentKey = ffjtFFJSONHotpink
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONHoneydew, kn) {
					currentKey = ffjtFFJSONHoneydew
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONGrey, kn) {
					currentKey = ffjtFFJSONGrey
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONGreenyellow, kn) {
					currentKey = ffjtFFJSONGreenyellow
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONGreen, kn) {
					currentKey = ffjtFFJSONGreen
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONGray, kn) {
					currentKey = ffjtFFJSONGray
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONGoldenrod, kn) {
					currentKey = ffjtFFJSONGoldenrod
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONGold, kn) {
					currentKey = ffjtFFJSONGold
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONGhostwhite, kn) {
					currentKey = ffjtFFJSONGhostwhite
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONGainsboro, kn) {
					currentKey = ffjtFFJSONGainsboro
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONFuchsia, kn) {
					currentKey = ffjtFFJSONFuchsia
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONForestgreen, kn) {
					currentKey = ffjtFFJSONForestgreen
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONFloralwhite, kn) {
					currentKey = ffjtFFJSONFloralwhite
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONFirebrick, kn) {
					currentKey = ffjtFFJSONFirebrick
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONDodgerblue, kn) {
					currentKey = ffjtFFJSONDodgerblue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONDimgrey, kn) {
					currentKey = ffjtFFJSONDimgrey
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONDimgray, kn) {
					currentKey = ffjtFFJSONDimgray
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONDeepskyblue, kn) {
					currentKey = ffjtFFJSONDeepskyblue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONDeeppink, kn) {
					currentKey = ffjtFFJSONDeeppink
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONDarkviolet, kn) {
					currentKey = ffjtFFJSONDarkviolet
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONDarkturquoise, kn) {
					currentKey = ffjtFFJSONDarkturquoise
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONDarkslategrey, kn) {
					currentKey = ffjtFFJSONDarkslategrey
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONDarkslategray, kn) {
					currentKey = ffjtFFJSONDarkslategray
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONDarkslateblue, kn) {
					currentKey = ffjtFFJSONDarkslateblue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONDarkseagreen, kn) {
					currentKey = ffjtFFJSONDarkseagreen
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONDarksalmon, kn) {
					currentKey = ffjtFFJSONDarksalmon
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONDarkred, kn) {
					currentKey = ffjtFFJSONDarkred
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONDarkorchid, kn) {
					currentKey = ffjtFFJSONDarkorchid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONDarkorange, kn) {
					currentKey = ffjtFFJSONDarkorange
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONDarkolivegreen, kn) {
					currentKey = ffjtFFJSONDarkolivegreen
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONDarkmagenta, kn) {
					currentKey = ffjtFFJSONDarkmagenta
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONDarkkhaki, kn) {
					currentKey = ffjtFFJSONDarkkhaki
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONDarkgrey, kn) {
					currentKey = ffjtFFJSONDarkgrey
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONDarkgreen, kn) {
					currentKey = ffjtFFJSONDarkgreen
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONDarkgray, kn) {
					currentKey = ffjtFFJSONDarkgray
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONDarkgoldenrod, kn) {
					currentKey = ffjtFFJSONDarkgoldenrod
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONDarkcyan, kn) {
					currentKey = ffjtFFJSONDarkcyan
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONDarkblue, kn) {
					currentKey = ffjtFFJSONDarkblue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONCyan, kn) {
					currentKey = ffjtFFJSONCyan
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONCrimson, kn) {
					currentKey = ffjtFFJSONCrimson
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONCornsilk, kn) {
					currentKey = ffjtFFJSONCornsilk
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONCornflowerblue, kn) {
					currentKey = ffjtFFJSONCornflowerblue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONCoral, kn) {
					currentKey = ffjtFFJSONCoral
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONChocolate, kn) {
					currentKey = ffjtFFJSONChocolate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONChartreuse, kn) {
					currentKey = ffjtFFJSONChartreuse
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONCadetblue, kn) {
					currentKey = ffjtFFJSONCadetblue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONBurlywood, kn) {
					currentKey = ffjtFFJSONBurlywood
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONBrown, kn) {
					currentKey = ffjtFFJSONBrown
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONBlueviolet, kn) {
					currentKey = ffjtFFJSONBlueviolet
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONBlue, kn) {
					currentKey = ffjtFFJSONBlue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONBlanchedalmond, kn) {
					currentKey = ffjtFFJSONBlanchedalmond
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONBlack, kn) {
					currentKey = ffjtFFJSONBlack
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFJSONBisque, kn) {
					currentKey = ffjtFFJSONBisque
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONBeige, kn) {
					currentKey = ffjtFFJSONBeige
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONAzure, kn) {
					currentKey = ffjtFFJSONAzure
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONAquamarine, kn) {
					currentKey = ffjtFFJSONAquamarine
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONAqua, kn) {
					currentKey = ffjtFFJSONAqua
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONAntiquewhite, kn) {
					currentKey = ffjtFFJSONAntiquewhite
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFJSONAliceblue, kn) {
					currentKey = ffjtFFJSONAliceblue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtFFJSONnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtFFJSONAliceblue:
					goto handle_Aliceblue

				case ffjtFFJSONAntiquewhite:
					goto handle_Antiquewhite

				case ffjtFFJSONAqua:
					goto handle_Aqua

				case ffjtFFJSONAquamarine:
					goto handle_Aquamarine

				case ffjtFFJSONAzure:
					goto handle_Azure

				case ffjtFFJSONBeige:
					goto handle_Beige

				case ffjtFFJSONBisque:
					goto handle_Bisque

				case ffjtFFJSONBlack:
					goto handle_Black

				case ffjtFFJSONBlanchedalmond:
					goto handle_Blanchedalmond

				case ffjtFFJSONBlue:
					goto handle_Blue

				case ffjtFFJSONBlueviolet:
					goto handle_Blueviolet

				case ffjtFFJSONBrown:
					goto handle_Brown

				case ffjtFFJSONBurlywood:
					goto handle_Burlywood

				case ffjtFFJSONCadetblue:
					goto handle_Cadetblue

				case ffjtFFJSONChartreuse:
					goto handle_Chartreuse

				case ffjtFFJSONChocolate:
					goto handle_Chocolate

				case ffjtFFJSONCoral:
					goto handle_Coral

				case ffjtFFJSONCornflowerblue:
					goto handle_Cornflowerblue

				case ffjtFFJSONCornsilk:
					goto handle_Cornsilk

				case ffjtFFJSONCrimson:
					goto handle_Crimson

				case ffjtFFJSONCyan:
					goto handle_Cyan

				case ffjtFFJSONDarkblue:
					goto handle_Darkblue

				case ffjtFFJSONDarkcyan:
					goto handle_Darkcyan

				case ffjtFFJSONDarkgoldenrod:
					goto handle_Darkgoldenrod

				case ffjtFFJSONDarkgray:
					goto handle_Darkgray

				case ffjtFFJSONDarkgreen:
					goto handle_Darkgreen

				case ffjtFFJSONDarkgrey:
					goto handle_Darkgrey

				case ffjtFFJSONDarkkhaki:
					goto handle_Darkkhaki

				case ffjtFFJSONDarkmagenta:
					goto handle_Darkmagenta

				case ffjtFFJSONDarkolivegreen:
					goto handle_Darkolivegreen

				case ffjtFFJSONDarkorange:
					goto handle_Darkorange

				case ffjtFFJSONDarkorchid:
					goto handle_Darkorchid

				case ffjtFFJSONDarkred:
					goto handle_Darkred

				case ffjtFFJSONDarksalmon:
					goto handle_Darksalmon

				case ffjtFFJSONDarkseagreen:
					goto handle_Darkseagreen

				case ffjtFFJSONDarkslateblue:
					goto handle_Darkslateblue

				case ffjtFFJSONDarkslategray:
					goto handle_Darkslategray

				case ffjtFFJSONDarkslategrey:
					goto handle_Darkslategrey

				case ffjtFFJSONDarkturquoise:
					goto handle_Darkturquoise

				case ffjtFFJSONDarkviolet:
					goto handle_Darkviolet

				case ffjtFFJSONDeeppink:
					goto handle_Deeppink

				case ffjtFFJSONDeepskyblue:
					goto handle_Deepskyblue

				case ffjtFFJSONDimgray:
					goto handle_Dimgray

				case ffjtFFJSONDimgrey:
					goto handle_Dimgrey

				case ffjtFFJSONDodgerblue:
					goto handle_Dodgerblue

				case ffjtFFJSONFirebrick:
					goto handle_Firebrick

				case ffjtFFJSONFloralwhite:
					goto handle_Floralwhite

				case ffjtFFJSONForestgreen:
					goto handle_Forestgreen

				case ffjtFFJSONFuchsia:
					goto handle_Fuchsia

				case ffjtFFJSONGainsboro:
					goto handle_Gainsboro

				case ffjtFFJSONGhostwhite:
					goto handle_Ghostwhite

				case ffjtFFJSONGold:
					goto handle_Gold

				case ffjtFFJSONGoldenrod:
					goto handle_Goldenrod

				case ffjtFFJSONGray:
					goto handle_Gray

				case ffjtFFJSONGreen:
					goto handle_Green

				case ffjtFFJSONGreenyellow:
					goto handle_Greenyellow

				case ffjtFFJSONGrey:
					goto handle_Grey

				case ffjtFFJSONHoneydew:
					goto handle_Honeydew

				case ffjtFFJSONHotpink:
					goto handle_Hotpink

				case ffjtFFJSONIndianred:
					goto handle_Indianred

				case ffjtFFJSONIndigo:
					goto handle_Indigo

				case ffjtFFJSONIvory:
					goto handle_Ivory

				case ffjtFFJSONKhaki:
					goto handle_Khaki

				case ffjtFFJSONLavender:
					goto handle_Lavender

				case ffjtFFJSONLavenderblush:
					goto handle_Lavenderblush

				case ffjtFFJSONLawngreen:
					goto handle_Lawngreen

				case ffjtFFJSONLemonchiffon:
					goto handle_Lemonchiffon

				case ffjtFFJSONLightblue:
					goto handle_Lightblue

				case ffjtFFJSONLightcoral:
					goto handle_Lightcoral

				case ffjtFFJSONLightcyan:
					goto handle_Lightcyan

				case ffjtFFJSONLightgoldenrodyellow:
					goto handle_Lightgoldenrodyellow

				case ffjtFFJSONLightgray:
					goto handle_Lightgray

				case ffjtFFJSONLightgreen:
					goto handle_Lightgreen

				case ffjtFFJSONLightgrey:
					goto handle_Lightgrey

				case ffjtFFJSONLightpink:
					goto handle_Lightpink

				case ffjtFFJSONLightsalmon:
					goto handle_Lightsalmon

				case ffjtFFJSONLightseagreen:
					goto handle_Lightseagreen

				case ffjtFFJSONLightskyblue:
					goto handle_Lightskyblue

				case ffjtFFJSONLightslategray:
					goto handle_Lightslategray

				case ffjtFFJSONLightslategrey:
					goto handle_Lightslategrey

				case ffjtFFJSONLightsteelblue:
					goto handle_Lightsteelblue

				case ffjtFFJSONLightyellow:
					goto handle_Lightyellow

				case ffjtFFJSONLime:
					goto handle_Lime

				case ffjtFFJSONLimegreen:
					goto handle_Limegreen

				case ffjtFFJSONLinen:
					goto handle_Linen

				case ffjtFFJSONMagenta:
					goto handle_Magenta

				case ffjtFFJSONMaroon:
					goto handle_Maroon

				case ffjtFFJSONMediumaquamarine:
					goto handle_Mediumaquamarine

				case ffjtFFJSONMediumblue:
					goto handle_Mediumblue

				case ffjtFFJSONMediumorchid:
					goto handle_Mediumorchid

				case ffjtFFJSONMediumpurple:
					goto handle_Mediumpurple

				case ffjtFFJSONMediumseagreen:
					goto handle_Mediumseagreen

				case ffjtFFJSONMediumslateblue:
					goto handle_Mediumslateblue

				case ffjtFFJSONMediumspringgreen:
					goto handle_Mediumspringgreen

				case ffjtFFJSONMediumturquoise:
					goto handle_Mediumturquoise

				case ffjtFFJSONMediumvioletred:
					goto handle_Mediumvioletred

				case ffjtFFJSONMidnightblue:
					goto handle_Midnightblue

				case ffjtFFJSONMintcream:
					goto handle_Mintcream

				case ffjtFFJSONMistyrose:
					goto handle_Mistyrose

				case ffjtFFJSONMoccasin:
					goto handle_Moccasin

				case ffjtFFJSONNavajowhite:
					goto handle_Navajowhite

				case ffjtFFJSONNavy:
					goto handle_Navy

				case ffjtFFJSONOldlace:
					goto handle_Oldlace

				case ffjtFFJSONOlive:
					goto handle_Olive

				case ffjtFFJSONOlivedrab:
					goto handle_Olivedrab

				case ffjtFFJSONOrange:
					goto handle_Orange

				case ffjtFFJSONOrangered:
					goto handle_Orangered

				case ffjtFFJSONOrchid:
					goto handle_Orchid

				case ffjtFFJSONPalegoldenrod:
					goto handle_Palegoldenrod

				case ffjtFFJSONPalegreen:
					goto handle_Palegreen

				case ffjtFFJSONPaleturquoise:
					goto handle_Paleturquoise

				case ffjtFFJSONPalevioletred:
					goto handle_Palevioletred

				case ffjtFFJSONPapayawhip:
					goto handle_Papayawhip

				case ffjtFFJSONPeachpuff:
					goto handle_Peachpuff

				case ffjtFFJSONPeru:
					goto handle_Peru

				case ffjtFFJSONPink:
					goto handle_Pink

				case ffjtFFJSONPlum:
					goto handle_Plum

				case ffjtFFJSONPowderblue:
					goto handle_Powderblue

				case ffjtFFJSONPurple:
					goto handle_Purple

				case ffjtFFJSONRebeccapurple:
					goto handle_Rebeccapurple

				case ffjtFFJSONRed:
					goto handle_Red

				case ffjtFFJSONRosybrown:
					goto handle_Rosybrown

				case ffjtFFJSONRoyalblue:
					goto handle_Royalblue

				case ffjtFFJSONSaddlebrown:
					goto handle_Saddlebrown

				case ffjtFFJSONSalmon:
					goto handle_Salmon

				case ffjtFFJSONSandybrown:
					goto handle_Sandybrown

				case ffjtFFJSONSeagreen:
					goto handle_Seagreen

				case ffjtFFJSONSeashell:
					goto handle_Seashell

				case ffjtFFJSONSienna:
					goto handle_Sienna

				case ffjtFFJSONSilver:
					goto handle_Silver

				case ffjtFFJSONSkyblue:
					goto handle_Skyblue

				case ffjtFFJSONSlateblue:
					goto handle_Slateblue

				case ffjtFFJSONSlategray:
					goto handle_Slategray

				case ffjtFFJSONSlategrey:
					goto handle_Slategrey

				case ffjtFFJSONSnow:
					goto handle_Snow

				case ffjtFFJSONSpringgreen:
					goto handle_Springgreen

				case ffjtFFJSONSteelblue:
					goto handle_Steelblue

				case ffjtFFJSONTan:
					goto handle_Tan

				case ffjtFFJSONTeal:
					goto handle_Teal

				case ffjtFFJSONThistle:
					goto handle_Thistle

				case ffjtFFJSONTomato:
					goto handle_Tomato

				case ffjtFFJSONTurquoise:
					goto handle_Turquoise

				case ffjtFFJSONViolet:
					goto handle_Violet

				case ffjtFFJSONWheat:
					goto handle_Wheat

				case ffjtFFJSONWhite:
					goto handle_White

				case ffjtFFJSONWhitesmoke:
					goto handle_Whitesmoke

				case ffjtFFJSONYellow:
					goto handle_Yellow

				case ffjtFFJSONYellowgreen:
					goto handle_Yellowgreen

				case ffjtFFJSONYoutube:
					goto handle_Youtube

				case ffjtFFJSONnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Aliceblue:

	/* handler: j.Aliceblue type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Aliceblue = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Antiquewhite:

	/* handler: j.Antiquewhite type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Antiquewhite = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Aqua:

	/* handler: j.Aqua type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Aqua = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Aquamarine:

	/* handler: j.Aquamarine type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Aquamarine = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Azure:

	/* handler: j.Azure type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Azure = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Beige:

	/* handler: j.Beige type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Beige = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Bisque:

	/* handler: j.Bisque type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Bisque = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Black:

	/* handler: j.Black type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Black = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Blanchedalmond:

	/* handler: j.Blanchedalmond type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Blanchedalmond = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Blue:

	/* handler: j.Blue type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Blue = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Blueviolet:

	/* handler: j.Blueviolet type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Blueviolet = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Brown:

	/* handler: j.Brown type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Brown = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Burlywood:

	/* handler: j.Burlywood type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Burlywood = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Cadetblue:

	/* handler: j.Cadetblue type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Cadetblue = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Chartreuse:

	/* handler: j.Chartreuse type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Chartreuse = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Chocolate:

	/* handler: j.Chocolate type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Chocolate = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Coral:

	/* handler: j.Coral type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Coral = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Cornflowerblue:

	/* handler: j.Cornflowerblue type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Cornflowerblue = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Cornsilk:

	/* handler: j.Cornsilk type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Cornsilk = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Crimson:

	/* handler: j.Crimson type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Crimson = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Cyan:

	/* handler: j.Cyan type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Cyan = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Darkblue:

	/* handler: j.Darkblue type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Darkblue = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Darkcyan:

	/* handler: j.Darkcyan type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Darkcyan = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Darkgoldenrod:

	/* handler: j.Darkgoldenrod type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Darkgoldenrod = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Darkgray:

	/* handler: j.Darkgray type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Darkgray = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Darkgreen:

	/* handler: j.Darkgreen type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Darkgreen = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Darkgrey:

	/* handler: j.Darkgrey type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Darkgrey = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Darkkhaki:

	/* handler: j.Darkkhaki type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Darkkhaki = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Darkmagenta:

	/* handler: j.Darkmagenta type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Darkmagenta = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Darkolivegreen:

	/* handler: j.Darkolivegreen type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Darkolivegreen = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Darkorange:

	/* handler: j.Darkorange type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Darkorange = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Darkorchid:

	/* handler: j.Darkorchid type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Darkorchid = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Darkred:

	/* handler: j.Darkred type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Darkred = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Darksalmon:

	/* handler: j.Darksalmon type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Darksalmon = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Darkseagreen:

	/* handler: j.Darkseagreen type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Darkseagreen = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Darkslateblue:

	/* handler: j.Darkslateblue type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Darkslateblue = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Darkslategray:

	/* handler: j.Darkslategray type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Darkslategray = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Darkslategrey:

	/* handler: j.Darkslategrey type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Darkslategrey = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Darkturquoise:

	/* handler: j.Darkturquoise type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Darkturquoise = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Darkviolet:

	/* handler: j.Darkviolet type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Darkviolet = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Deeppink:

	/* handler: j.Deeppink type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Deeppink = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Deepskyblue:

	/* handler: j.Deepskyblue type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Deepskyblue = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Dimgray:

	/* handler: j.Dimgray type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Dimgray = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Dimgrey:

	/* handler: j.Dimgrey type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Dimgrey = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Dodgerblue:

	/* handler: j.Dodgerblue type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Dodgerblue = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Firebrick:

	/* handler: j.Firebrick type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Firebrick = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Floralwhite:

	/* handler: j.Floralwhite type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Floralwhite = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Forestgreen:

	/* handler: j.Forestgreen type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Forestgreen = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Fuchsia:

	/* handler: j.Fuchsia type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Fuchsia = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Gainsboro:

	/* handler: j.Gainsboro type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Gainsboro = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ghostwhite:

	/* handler: j.Ghostwhite type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Ghostwhite = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Gold:

	/* handler: j.Gold type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Gold = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Goldenrod:

	/* handler: j.Goldenrod type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Goldenrod = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Gray:

	/* handler: j.Gray type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Gray = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Green:

	/* handler: j.Green type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Green = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Greenyellow:

	/* handler: j.Greenyellow type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Greenyellow = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Grey:

	/* handler: j.Grey type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Grey = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Honeydew:

	/* handler: j.Honeydew type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Honeydew = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Hotpink:

	/* handler: j.Hotpink type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Hotpink = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Indianred:

	/* handler: j.Indianred type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Indianred = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Indigo:

	/* handler: j.Indigo type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Indigo = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ivory:

	/* handler: j.Ivory type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Ivory = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Khaki:

	/* handler: j.Khaki type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Khaki = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Lavender:

	/* handler: j.Lavender type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Lavender = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Lavenderblush:

	/* handler: j.Lavenderblush type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Lavenderblush = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Lawngreen:

	/* handler: j.Lawngreen type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Lawngreen = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Lemonchiffon:

	/* handler: j.Lemonchiffon type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Lemonchiffon = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Lightblue:

	/* handler: j.Lightblue type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Lightblue = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Lightcoral:

	/* handler: j.Lightcoral type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Lightcoral = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Lightcyan:

	/* handler: j.Lightcyan type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Lightcyan = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Lightgoldenrodyellow:

	/* handler: j.Lightgoldenrodyellow type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Lightgoldenrodyellow = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Lightgray:

	/* handler: j.Lightgray type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Lightgray = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Lightgreen:

	/* handler: j.Lightgreen type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Lightgreen = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Lightgrey:

	/* handler: j.Lightgrey type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Lightgrey = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Lightpink:

	/* handler: j.Lightpink type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Lightpink = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Lightsalmon:

	/* handler: j.Lightsalmon type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Lightsalmon = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Lightseagreen:

	/* handler: j.Lightseagreen type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Lightseagreen = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Lightskyblue:

	/* handler: j.Lightskyblue type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Lightskyblue = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Lightslategray:

	/* handler: j.Lightslategray type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Lightslategray = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Lightslategrey:

	/* handler: j.Lightslategrey type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Lightslategrey = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Lightsteelblue:

	/* handler: j.Lightsteelblue type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Lightsteelblue = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Lightyellow:

	/* handler: j.Lightyellow type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Lightyellow = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Lime:

	/* handler: j.Lime type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Lime = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Limegreen:

	/* handler: j.Limegreen type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Limegreen = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Linen:

	/* handler: j.Linen type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Linen = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Magenta:

	/* handler: j.Magenta type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Magenta = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Maroon:

	/* handler: j.Maroon type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Maroon = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mediumaquamarine:

	/* handler: j.Mediumaquamarine type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Mediumaquamarine = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mediumblue:

	/* handler: j.Mediumblue type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Mediumblue = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mediumorchid:

	/* handler: j.Mediumorchid type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Mediumorchid = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mediumpurple:

	/* handler: j.Mediumpurple type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Mediumpurple = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mediumseagreen:

	/* handler: j.Mediumseagreen type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Mediumseagreen = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mediumslateblue:

	/* handler: j.Mediumslateblue type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Mediumslateblue = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mediumspringgreen:

	/* handler: j.Mediumspringgreen type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Mediumspringgreen = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mediumturquoise:

	/* handler: j.Mediumturquoise type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Mediumturquoise = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mediumvioletred:

	/* handler: j.Mediumvioletred type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Mediumvioletred = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Midnightblue:

	/* handler: j.Midnightblue type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Midnightblue = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mintcream:

	/* handler: j.Mintcream type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Mintcream = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mistyrose:

	/* handler: j.Mistyrose type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Mistyrose = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Moccasin:

	/* handler: j.Moccasin type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Moccasin = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Navajowhite:

	/* handler: j.Navajowhite type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Navajowhite = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Navy:

	/* handler: j.Navy type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Navy = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Oldlace:

	/* handler: j.Oldlace type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Oldlace = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Olive:

	/* handler: j.Olive type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Olive = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Olivedrab:

	/* handler: j.Olivedrab type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Olivedrab = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Orange:

	/* handler: j.Orange type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Orange = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Orangered:

	/* handler: j.Orangered type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Orangered = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Orchid:

	/* handler: j.Orchid type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Orchid = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Palegoldenrod:

	/* handler: j.Palegoldenrod type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Palegoldenrod = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Palegreen:

	/* handler: j.Palegreen type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Palegreen = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Paleturquoise:

	/* handler: j.Paleturquoise type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Paleturquoise = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Palevioletred:

	/* handler: j.Palevioletred type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Palevioletred = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Papayawhip:

	/* handler: j.Papayawhip type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Papayawhip = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Peachpuff:

	/* handler: j.Peachpuff type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Peachpuff = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Peru:

	/* handler: j.Peru type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Peru = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Pink:

	/* handler: j.Pink type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Pink = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Plum:

	/* handler: j.Plum type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Plum = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Powderblue:

	/* handler: j.Powderblue type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Powderblue = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Purple:

	/* handler: j.Purple type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Purple = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Rebeccapurple:

	/* handler: j.Rebeccapurple type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Rebeccapurple = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Red:

	/* handler: j.Red type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Red = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Rosybrown:

	/* handler: j.Rosybrown type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Rosybrown = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Royalblue:

	/* handler: j.Royalblue type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Royalblue = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Saddlebrown:

	/* handler: j.Saddlebrown type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Saddlebrown = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Salmon:

	/* handler: j.Salmon type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Salmon = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Sandybrown:

	/* handler: j.Sandybrown type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Sandybrown = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Seagreen:

	/* handler: j.Seagreen type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Seagreen = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Seashell:

	/* handler: j.Seashell type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Seashell = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Sienna:

	/* handler: j.Sienna type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Sienna = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Silver:

	/* handler: j.Silver type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Silver = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Skyblue:

	/* handler: j.Skyblue type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Skyblue = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Slateblue:

	/* handler: j.Slateblue type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Slateblue = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Slategray:

	/* handler: j.Slategray type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Slategray = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Slategrey:

	/* handler: j.Slategrey type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Slategrey = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Snow:

	/* handler: j.Snow type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Snow = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Springgreen:

	/* handler: j.Springgreen type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Springgreen = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Steelblue:

	/* handler: j.Steelblue type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Steelblue = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Tan:

	/* handler: j.Tan type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Tan = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Teal:

	/* handler: j.Teal type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Teal = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Thistle:

	/* handler: j.Thistle type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Thistle = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Tomato:

	/* handler: j.Tomato type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Tomato = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Turquoise:

	/* handler: j.Turquoise type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Turquoise = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Violet:

	/* handler: j.Violet type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Violet = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Wheat:

	/* handler: j.Wheat type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Wheat = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_White:

	/* handler: j.White type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.White = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Whitesmoke:

	/* handler: j.Whitesmoke type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Whitesmoke = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Yellow:

	/* handler: j.Yellow type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Yellow = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Yellowgreen:

	/* handler: j.Yellowgreen type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Yellowgreen = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Youtube:

	/* handler: j.Youtube type=structs.FFYoutube kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.Youtube.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *FFLocalized) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *FFLocalized) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"description":`)
	fflib.WriteJsonString(buf, string(j.Description))
	buf.WriteString(`,"title":`)
	fflib.WriteJsonString(buf, string(j.Title))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtFFLocalizedbase = iota
	ffjtFFLocalizednosuchkey

	ffjtFFLocalizedDescription

	ffjtFFLocalizedTitle
)

var ffjKeyFFLocalizedDescription = []byte("description")

var ffjKeyFFLocalizedTitle = []byte("title")

// UnmarshalJSON umarshall json - template of ffjson
func (j *FFLocalized) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *FFLocalized) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtFFLocalizedbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtFFLocalizednosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffjKeyFFLocalizedDescription, kn) {
						currentKey = ffjtFFLocalizedDescription
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyFFLocalizedTitle, kn) {
						currentKey = ffjtFFLocalizedTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFLocalizedTitle, kn) {
					currentKey = ffjtFFLocalizedTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFLocalizedDescription, kn) {
					currentKey = ffjtFFLocalizedDescription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtFFLocalizednosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtFFLocalizedDescription:
					goto handle_Description

				case ffjtFFLocalizedTitle:
					goto handle_Title

				case ffjtFFLocalizednosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Description:

	/* handler: j.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *FFPageInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *FFPageInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"resultsPerPage":`)
	fflib.FormatBits2(buf, uint64(j.ResultsPerPage), 10, j.ResultsPerPage < 0)
	buf.WriteString(`,"totalResults":`)
	fflib.FormatBits2(buf, uint64(j.TotalResults), 10, j.TotalResults < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtFFPageInfobase = iota
	ffjtFFPageInfonosuchkey

	ffjtFFPageInfoResultsPerPage

	ffjtFFPageInfoTotalResults
)

var ffjKeyFFPageInfoResultsPerPage = []byte("resultsPerPage")

var ffjKeyFFPageInfoTotalResults = []byte("totalResults")

// UnmarshalJSON umarshall json - template of ffjson
func (j *FFPageInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *FFPageInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtFFPageInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtFFPageInfonosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'r':

					if bytes.Equal(ffjKeyFFPageInfoResultsPerPage, kn) {
						currentKey = ffjtFFPageInfoResultsPerPage
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyFFPageInfoTotalResults, kn) {
						currentKey = ffjtFFPageInfoTotalResults
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyFFPageInfoTotalResults, kn) {
					currentKey = ffjtFFPageInfoTotalResults
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFPageInfoResultsPerPage, kn) {
					currentKey = ffjtFFPageInfoResultsPerPage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtFFPageInfonosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtFFPageInfoResultsPerPage:
					goto handle_ResultsPerPage

				case ffjtFFPageInfoTotalResults:
					goto handle_TotalResults

				case ffjtFFPageInfonosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ResultsPerPage:

	/* handler: j.ResultsPerPage type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ResultsPerPage = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TotalResults:

	/* handler: j.TotalResults type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.TotalResults = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *FFSnippet) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *FFSnippet) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"categoryId":`)
	fflib.WriteJsonString(buf, string(j.CategoryID))
	buf.WriteString(`,"channelId":`)
	fflib.WriteJsonString(buf, string(j.ChannelID))
	buf.WriteString(`,"channelTitle":`)
	fflib.WriteJsonString(buf, string(j.ChannelTitle))
	buf.WriteString(`,"description":`)
	fflib.WriteJsonString(buf, string(j.Description))
	buf.WriteString(`,"liveBroadcastContent":`)
	fflib.WriteJsonString(buf, string(j.LiveBroadcastContent))
	buf.WriteString(`,"localized":`)

	{

		err = j.Localized.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"publishedAt":`)
	fflib.WriteJsonString(buf, string(j.PublishedAt))
	buf.WriteString(`,"thumbnails":`)

	{

		err = j.Thumbnails.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"title":`)
	fflib.WriteJsonString(buf, string(j.Title))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtFFSnippetbase = iota
	ffjtFFSnippetnosuchkey

	ffjtFFSnippetCategoryID

	ffjtFFSnippetChannelID

	ffjtFFSnippetChannelTitle

	ffjtFFSnippetDescription

	ffjtFFSnippetLiveBroadcastContent

	ffjtFFSnippetLocalized

	ffjtFFSnippetPublishedAt

	ffjtFFSnippetThumbnails

	ffjtFFSnippetTitle
)

var ffjKeyFFSnippetCategoryID = []byte("categoryId")

var ffjKeyFFSnippetChannelID = []byte("channelId")

var ffjKeyFFSnippetChannelTitle = []byte("channelTitle")

var ffjKeyFFSnippetDescription = []byte("description")

var ffjKeyFFSnippetLiveBroadcastContent = []byte("liveBroadcastContent")

var ffjKeyFFSnippetLocalized = []byte("localized")

var ffjKeyFFSnippetPublishedAt = []byte("publishedAt")

var ffjKeyFFSnippetThumbnails = []byte("thumbnails")

var ffjKeyFFSnippetTitle = []byte("title")

// UnmarshalJSON umarshall json - template of ffjson
func (j *FFSnippet) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *FFSnippet) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtFFSnippetbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtFFSnippetnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyFFSnippetCategoryID, kn) {
						currentKey = ffjtFFSnippetCategoryID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFSnippetChannelID, kn) {
						currentKey = ffjtFFSnippetChannelID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFSnippetChannelTitle, kn) {
						currentKey = ffjtFFSnippetChannelTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyFFSnippetDescription, kn) {
						currentKey = ffjtFFSnippetDescription
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyFFSnippetLiveBroadcastContent, kn) {
						currentKey = ffjtFFSnippetLiveBroadcastContent
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFSnippetLocalized, kn) {
						currentKey = ffjtFFSnippetLocalized
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyFFSnippetPublishedAt, kn) {
						currentKey = ffjtFFSnippetPublishedAt
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyFFSnippetThumbnails, kn) {
						currentKey = ffjtFFSnippetThumbnails
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFSnippetTitle, kn) {
						currentKey = ffjtFFSnippetTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFSnippetTitle, kn) {
					currentKey = ffjtFFSnippetTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFSnippetThumbnails, kn) {
					currentKey = ffjtFFSnippetThumbnails
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFSnippetPublishedAt, kn) {
					currentKey = ffjtFFSnippetPublishedAt
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFSnippetLocalized, kn) {
					currentKey = ffjtFFSnippetLocalized
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFSnippetLiveBroadcastContent, kn) {
					currentKey = ffjtFFSnippetLiveBroadcastContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFSnippetDescription, kn) {
					currentKey = ffjtFFSnippetDescription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFSnippetChannelTitle, kn) {
					currentKey = ffjtFFSnippetChannelTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFSnippetChannelID, kn) {
					currentKey = ffjtFFSnippetChannelID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFSnippetCategoryID, kn) {
					currentKey = ffjtFFSnippetCategoryID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtFFSnippetnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtFFSnippetCategoryID:
					goto handle_CategoryID

				case ffjtFFSnippetChannelID:
					goto handle_ChannelID

				case ffjtFFSnippetChannelTitle:
					goto handle_ChannelTitle

				case ffjtFFSnippetDescription:
					goto handle_Description

				case ffjtFFSnippetLiveBroadcastContent:
					goto handle_LiveBroadcastContent

				case ffjtFFSnippetLocalized:
					goto handle_Localized

				case ffjtFFSnippetPublishedAt:
					goto handle_PublishedAt

				case ffjtFFSnippetThumbnails:
					goto handle_Thumbnails

				case ffjtFFSnippetTitle:
					goto handle_Title

				case ffjtFFSnippetnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_CategoryID:

	/* handler: j.CategoryID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.CategoryID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChannelID:

	/* handler: j.ChannelID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ChannelID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChannelTitle:

	/* handler: j.ChannelTitle type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ChannelTitle = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: j.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LiveBroadcastContent:

	/* handler: j.LiveBroadcastContent type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.LiveBroadcastContent = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Localized:

	/* handler: j.Localized type=structs.FFLocalized kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.Localized.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PublishedAt:

	/* handler: j.PublishedAt type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.PublishedAt = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Thumbnails:

	/* handler: j.Thumbnails type=structs.FFThumbnails kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.Thumbnails.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *FFThumbnails) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *FFThumbnails) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"default":`)

	{

		err = j.Default.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"high":`)

	{

		err = j.High.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"maxres":`)

	{

		err = j.Maxres.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"medium":`)

	{

		err = j.Medium.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"standard":`)

	{

		err = j.Standard.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtFFThumbnailsbase = iota
	ffjtFFThumbnailsnosuchkey

	ffjtFFThumbnailsDefault

	ffjtFFThumbnailsHigh

	ffjtFFThumbnailsMaxres

	ffjtFFThumbnailsMedium

	ffjtFFThumbnailsStandard
)

var ffjKeyFFThumbnailsDefault = []byte("default")

var ffjKeyFFThumbnailsHigh = []byte("high")

var ffjKeyFFThumbnailsMaxres = []byte("maxres")

var ffjKeyFFThumbnailsMedium = []byte("medium")

var ffjKeyFFThumbnailsStandard = []byte("standard")

// UnmarshalJSON umarshall json - template of ffjson
func (j *FFThumbnails) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *FFThumbnails) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtFFThumbnailsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtFFThumbnailsnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffjKeyFFThumbnailsDefault, kn) {
						currentKey = ffjtFFThumbnailsDefault
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffjKeyFFThumbnailsHigh, kn) {
						currentKey = ffjtFFThumbnailsHigh
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyFFThumbnailsMaxres, kn) {
						currentKey = ffjtFFThumbnailsMaxres
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFFThumbnailsMedium, kn) {
						currentKey = ffjtFFThumbnailsMedium
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyFFThumbnailsStandard, kn) {
						currentKey = ffjtFFThumbnailsStandard
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyFFThumbnailsStandard, kn) {
					currentKey = ffjtFFThumbnailsStandard
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFThumbnailsMedium, kn) {
					currentKey = ffjtFFThumbnailsMedium
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFThumbnailsMaxres, kn) {
					currentKey = ffjtFFThumbnailsMaxres
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFThumbnailsHigh, kn) {
					currentKey = ffjtFFThumbnailsHigh
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFThumbnailsDefault, kn) {
					currentKey = ffjtFFThumbnailsDefault
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtFFThumbnailsnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtFFThumbnailsDefault:
					goto handle_Default

				case ffjtFFThumbnailsHigh:
					goto handle_High

				case ffjtFFThumbnailsMaxres:
					goto handle_Maxres

				case ffjtFFThumbnailsMedium:
					goto handle_Medium

				case ffjtFFThumbnailsStandard:
					goto handle_Standard

				case ffjtFFThumbnailsnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Default:

	/* handler: j.Default type=structs.FFThumbnailsInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.Default.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_High:

	/* handler: j.High type=structs.FFThumbnailsInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.High.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Maxres:

	/* handler: j.Maxres type=structs.FFThumbnailsInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.Maxres.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Medium:

	/* handler: j.Medium type=structs.FFThumbnailsInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.Medium.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Standard:

	/* handler: j.Standard type=structs.FFThumbnailsInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.Standard.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *FFThumbnailsInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *FFThumbnailsInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"height":`)
	fflib.FormatBits2(buf, uint64(j.Height), 10, j.Height < 0)
	buf.WriteString(`,"url":`)
	fflib.WriteJsonString(buf, string(j.URL))
	buf.WriteString(`,"width":`)
	fflib.FormatBits2(buf, uint64(j.Width), 10, j.Width < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtFFThumbnailsInfobase = iota
	ffjtFFThumbnailsInfonosuchkey

	ffjtFFThumbnailsInfoHeight

	ffjtFFThumbnailsInfoURL

	ffjtFFThumbnailsInfoWidth
)

var ffjKeyFFThumbnailsInfoHeight = []byte("height")

var ffjKeyFFThumbnailsInfoURL = []byte("url")

var ffjKeyFFThumbnailsInfoWidth = []byte("width")

// UnmarshalJSON umarshall json - template of ffjson
func (j *FFThumbnailsInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *FFThumbnailsInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtFFThumbnailsInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtFFThumbnailsInfonosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'h':

					if bytes.Equal(ffjKeyFFThumbnailsInfoHeight, kn) {
						currentKey = ffjtFFThumbnailsInfoHeight
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyFFThumbnailsInfoURL, kn) {
						currentKey = ffjtFFThumbnailsInfoURL
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffjKeyFFThumbnailsInfoWidth, kn) {
						currentKey = ffjtFFThumbnailsInfoWidth
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFThumbnailsInfoWidth, kn) {
					currentKey = ffjtFFThumbnailsInfoWidth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFThumbnailsInfoURL, kn) {
					currentKey = ffjtFFThumbnailsInfoURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFThumbnailsInfoHeight, kn) {
					currentKey = ffjtFFThumbnailsInfoHeight
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtFFThumbnailsInfonosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtFFThumbnailsInfoHeight:
					goto handle_Height

				case ffjtFFThumbnailsInfoURL:
					goto handle_URL

				case ffjtFFThumbnailsInfoWidth:
					goto handle_Width

				case ffjtFFThumbnailsInfonosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Height:

	/* handler: j.Height type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Height = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_URL:

	/* handler: j.URL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.URL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Width:

	/* handler: j.Width type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Width = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *FFYoutube) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *FFYoutube) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"etag":`)
	fflib.WriteJsonString(buf, string(j.Etag))
	buf.WriteString(`,"items":`)
	if j.Items != nil {
		buf.WriteString(`[`)
		for i, v := range j.Items {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"kind":`)
	fflib.WriteJsonString(buf, string(j.Kind))
	buf.WriteString(`,"nextPageToken":`)
	fflib.WriteJsonString(buf, string(j.NextPageToken))
	buf.WriteString(`,"pageInfo":`)

	{

		err = j.PageInfo.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtFFYoutubebase = iota
	ffjtFFYoutubenosuchkey

	ffjtFFYoutubeEtag

	ffjtFFYoutubeItems

	ffjtFFYoutubeKind

	ffjtFFYoutubeNextPageToken

	ffjtFFYoutubePageInfo
)

var ffjKeyFFYoutubeEtag = []byte("etag")

var ffjKeyFFYoutubeItems = []byte("items")

var ffjKeyFFYoutubeKind = []byte("kind")

var ffjKeyFFYoutubeNextPageToken = []byte("nextPageToken")

var ffjKeyFFYoutubePageInfo = []byte("pageInfo")

// UnmarshalJSON umarshall json - template of ffjson
func (j *FFYoutube) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *FFYoutube) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtFFYoutubebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtFFYoutubenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'e':

					if bytes.Equal(ffjKeyFFYoutubeEtag, kn) {
						currentKey = ffjtFFYoutubeEtag
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyFFYoutubeItems, kn) {
						currentKey = ffjtFFYoutubeItems
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffjKeyFFYoutubeKind, kn) {
						currentKey = ffjtFFYoutubeKind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyFFYoutubeNextPageToken, kn) {
						currentKey = ffjtFFYoutubeNextPageToken
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyFFYoutubePageInfo, kn) {
						currentKey = ffjtFFYoutubePageInfo
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFYoutubePageInfo, kn) {
					currentKey = ffjtFFYoutubePageInfo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFYoutubeNextPageToken, kn) {
					currentKey = ffjtFFYoutubeNextPageToken
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFYoutubeKind, kn) {
					currentKey = ffjtFFYoutubeKind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFFYoutubeItems, kn) {
					currentKey = ffjtFFYoutubeItems
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyFFYoutubeEtag, kn) {
					currentKey = ffjtFFYoutubeEtag
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtFFYoutubenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtFFYoutubeEtag:
					goto handle_Etag

				case ffjtFFYoutubeItems:
					goto handle_Items

				case ffjtFFYoutubeKind:
					goto handle_Kind

				case ffjtFFYoutubeNextPageToken:
					goto handle_NextPageToken

				case ffjtFFYoutubePageInfo:
					goto handle_PageInfo

				case ffjtFFYoutubenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Etag:

	/* handler: j.Etag type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Etag = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Items:

	/* handler: j.Items type=[]structs.FFItems kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Items = nil
		} else {

			j.Items = []FFItems{}

			wantVal := true

			for {

				var tmpJItems FFItems

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJItems type=structs.FFItems kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJItems.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Items = append(j.Items, tmpJItems)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Kind:

	/* handler: j.Kind type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Kind = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NextPageToken:

	/* handler: j.NextPageToken type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.NextPageToken = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PageInfo:

	/* handler: j.PageInfo type=structs.FFPageInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.PageInfo.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}
